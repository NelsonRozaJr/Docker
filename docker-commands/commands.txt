CONTAINERES

Obs.: <container_id> - Id ou nome de um container.

* Lista os containeres em execução:
$ docker container ps

* Lista todos os containeres:
$ docker container ps -a

* Lista os ids de todos os containeres em execução:
$ docker container ps -q

* Lista todos os containeres em execução, especificando também o tamanho:
$ docker container ps -s

* Inspeciona o container:
$ docker container inspect <container_id>

* Inspeciona o container e filtra a informação desejada:
$ docker container inspect --format='{{.Config.Hostname}}' <container_id>

* Exibe logs de criação de um container:
$ docker container logs <container_id>

* Renomeia um container:
$ docker container rename <old_name> <new_name>

* Remove o container especificado. O container não pode estar em execução:
$ docker container rm <container_id>

* Remove o container mesmo se estiver em execução:
$ docker container rm --force <container_id>

* Remove todos os containeres parados:
$ docker container prune

* Inicia um container:
$ docker container start <container_id>
$ docker container start -ia <container_id>
-ia: inicia o container no modo interativo com terminal atachado.

* Acessa o terminal de um container executando em background.
- Ao sair do container usando "exit", o mesmo é parado.
- Ao sair do container usando a combinação de teclas ^P e ^Q, o container continua em execução (^ = Ctrl).
$ docker container attach <container_id>

* Copia um arquivo de dentro do container para o diretório corrente do host:
$ docker container cp <container_name>:/tmp/File01.txt .

* Copia um arquivo do diretório atual do host para dentro do container:
$ docker container cp File01.txt relaxed_morse:/tmp/File01.txt

* Executa um comando em um container em execução:
$ docker container exec <container_id> <command>

* Para o container:
$ docker container stop <container_id>

* Obtém informações do container e execução, como uso de cpu, de memória, I/O, etc.:
$ docker container stats <container_id>

* Faz backup de um container, exportando o seu sistema de arquivos na forma compactada:
$ docker container export <container_id> | gzip > container_export.tar.gz

* Descompacta e importa o container de backup na forma de uma imagem:
-: Concatena a saída do comando anterior.
$ zcat container_export.tar.gz | docker import - container_import

* Containeres importados na forma de imagem devem especificar o comando ao criar o container:
$ docker container run -it container_import bash

========================================================================================================================================

IMAGENS

Obs.: <image_id> - Id ou nome de uma imagem.

* Lista todas as imagens baixadas no repositório local:
$ docker images

* Remove todas as imagens que não possuem containeres associados (será exibido um prompt de confirmação):
$ docker image prune -a

* Baixa para o repositório local somente a imagem especificada do docker hub:
$ docker image pull nginx

* Remove a imagem especificada. A imagem não pode estar associada a nenhum container:
$ docker image rm <image_id>

* Exibe informações detalhadas de uma imagem:
$ docker image inspect <image_id>

* Faz backup de uma imagem na forma compactada:
$ docker image save <image_id> | gzip > image_export.tar.gz

* Importa uma imagem compactada:
$ docker image load < image_export.tar.gz

========================================================================================================================================

BUSCA DE IMAGENS NO DOCKER HUB

$ docker search nano

========================================================================================================================================

BUILD DE IMAGES

$ docker image build -t debian/nginx:1.0 .
-t: Nome e opcionalmente uma tag no formato 'name:tag'.
.: Informa que o arquivo Dockerfile está no mesmo diretório em que o comando é executado.

* Faz upload da imagem para o repositório do docker hub:
$ docker login
$ docker image tag debian/nginx:1.0 nelsonrzjunior/course:debian8
$ docker image push nelsonrzjunior/course:debian8

========================================================================================================================================

UPLOAD DE IMAGEM PARA O DOCKER HUB

* Para gerar o token de senha: https://hub.docker.com/settings/security. Somente necessário informar as credenciais na primeira vez:
$ docker login --username nelsonrzjunior --password 053174f3-e3b5-4cff-b501-983198a34f27
$ docker tag netcoreproduct:1.0 nelsonrzjunior/course:netcoreproduct-1.0
$ docker push nelsonrzjunior/course:netcoreproduct-1.0

========================================================================================================================================

VOLUMES

* Cria um volume:
$ docker volume create <volume_name>

* Lista os volumes existentes:
$ docker volume ls

* Exibe informações detalhadas de um volume
$ docker volume inspect <volume_name>

* Remove um volume
$ docker volume rm <volume_name>

* Remove todos os volumes (será exibido um prompt de confirmação):
$ docker volume prune

========================================================================================================================================

CRIAÇÃO DE CONTAINERES

$ docker container run hello-world
Realiza as seguintes operações:
* Download automático da imagem do docker hub se não foi encontrada localmente: docker image pull hello-world
* Cria o container: docker container create hello-world
* Inicia o container: docker container start <container_id>
* Usa o modo interativo para executar um comando em um container em execução: docker container exec -i <container_id> <command>

$ docker container run -d --name <container_name> -p 8080:80 -v /d/Projects/docker/nginx/html:/usr/share/nginx/html nginx
run: (cria, inicia e executa o container)
-d: executa o container em modo de background
--name: nome do container
-p: mapeamento de portas entre host e container
-v: mapeamento de diretórios entre host e container. A pasta 'Projects' é case-sensitive e deve ser definida exatamente como na VM (Shared Folders).
nginx: imagem a partir da qual será gerada o container

* Cria um container baseado na imagem do alpine, executa um comando dentro do container, sai do container e exibe 
o resultado do comando no terminal:
$ docker container run alpine ls -l

* Cria um container baseado na imagem do alpine de tag 3.12, com terminal aberto dentro do container:
$ docker container run -it alpine:3.12

* Cria um container baseado na imagem do alpine de tag 3.12, com terminal aberto dentro do container (-it) e exclui o 
container ao sair do terminal (--rm):
$ docker container run -it --rm alpine:3.12

$ docker container run --name <container_name> -p 8080:80 -v /d/Projects/Docker/volumes/nginx/html:/usr/share/nginx/html -d nginx
--name: nome do container
-p: mapeamento de portas (host:container)
-v: mapeamento de volume ou pasta (host:container)
-d: executa o comando em segundo plano, evitando o travamento do terminal (detached)
nginx (lê-se engine-x): nome da imagem

$ docker container run --name <container_name> -it mcr.microsoft.com/dotnet/core/sdk
--name: nome do container
-it: modo interativo com terminal aberto dentro do container
mcr.microsoft.com/dotnet/core/sdk: nome da imagem

* Compartilhar o volume "Volume1" criado no container "container1" com o container "container2":
$ docker container run -it --name container1 -v /Volume1 alpine
$ docker container run -it --name container2 --volumes-from container1 alpine
- Para posteriormente acessar os containeres criados acima: docker container start -ia <container_name>

* Utiliza a memória RAM (volátil) do host para persistir dados do container:
$ docker container run -itd --name <container_name> --tmpfs /tmp busybox

* Verifica a utilização do espaço em disco dentro do container:
$ docker container exec <container_name> df -h

========================================================================================================================================

CONTAINER DE BANCO DE DADOS

* Abre um terminal dentro do container criado acima:
$ docker container exec -it mysql /bin/bash

* Login no mysql do container um prompt solicitará a senha, no caso, 12345678)
/# mysql -u root -p

* Já dentro do mysql, exibe os banco de dados:
mysql> show databases;

* Acessa um banco de dados:
mysql> use ProductDB;

========================================================================================================================================

REDES VIRTUAIS OU DEFINIDAS POR SOFTWARE

* Exibe as redes virtuais do Docker. A rede "bridge" é a rede padrão na qual os containeres são incluidos. Os containers que estão nessa rede podem se comunicar via protocolo TCP/IP
$ docker network ls

* Inspeciona o driver de rede especificado. O Docker configura a rede virtual e atribui um endereço IP a cada container em execução, 
que são exibidos na seção "Containers":
$ docker network inspect bridge

* Cria uma rede personalizada. O nome do container passa a agir como um host name.
$ docker network create --driver bridge <my-network>
--driver: o driver de rede a ser utilizado. Se não for informado, o Docker utiliza o driver "bridge".

* Cria um container configurando uma rede personalizada:
$ docker container run -it --network <my-network> --name <container_name> alpine

* Cria um container baseado na imagem do apache sem "ponte" entre o host e o container. Dessa forma é possível acessar o container sem 
informar a porta de acesso:
$ docker container run -d --network host httpd
$ curl 192.168.99.100

* Associa um container a uma rede customizada:
$ docker network connect <my-network> <container_name>

========================================================================================================================================

DOCKER COMPOSE

* Verifica a sintaxe do arquivo de composição e cria a imagem:
$ docker-compose build

* Verifica a sintaxe do arquivo de composição e cria a imagem, utilizando um arquivo com nome diferente do padrão:
$ docker-compose -f docker-compose-dev.yml -p dev build
-p: utiliza um nome de projeto alternativo para nomear os elementos criados pelo arquivo de composição

* Processa o arquivo de composição em segundo plano e inicia a aplicação:
$ docker-compose up -d

* Processa o arquivo de composição em segundo plano e inicia a aplicação, utilizando um arquivo com nome diferente do padrão:
$ docker-compose -f docker-compose-dev.yml -p dev up
-p: utiliza um prefixo para nomear os elementos criados pelo arquivo de composição

* Verifica os containeres criados:
$ docker-compose ps

* Verifica os logs gerados:
$ docker-compose logs

* Remove os containeres, volumes e redes descritas no arquivo de composição:
$ docker-compose down -v

========================================================================================================================================

DOCKER MACHINE

* Exibe a url da máquina virtual:
$ docker-machine url

* Para a máquina virtual:
$ docker-machine stop

* Inicia a máquina virtual:
$ docker-machine start

========================================================================================================================================

COMANDOS UNIX

* Listagem de diretórios:
$ ls -g

* Acessa o diretório especificado:
$ cd <dir-name>

* Cria o diretório especificado:
$ mkdir <dir-name>

* Remove o diretório especificado:
$ rmdir <dir-name>

========================================================================================================================================
