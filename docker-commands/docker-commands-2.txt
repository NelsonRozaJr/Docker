* Lista todas as imagens baixadas localmente:
$ docker images

* Remove a imagem especificada (id ou nome). A imagem não pode estar associada a nenhum container:
$ docker image rm <image_id>

* Lista os containeres em execução:
$ docker container ps

* Lista todos os containeres:
$ docker container ps -a

* Lista os ids de todos os containeres:
$ docker container ps -q

* Remove o container especificado (id ou nome). O container não pode estar em execução:
$ docker container rm <container_id>

* Remove todos os containeres parados:
$ docker container prune

* Inicia o container:
$ docker container start <container_id>

$ docker container start -ia <container_id>
-ia: inicia o container no modo interativo com terminal atachado.

* Executa um comando no container especificado:
$ docker container exec <container_id> <command>

* Para o container:
$ docker container stop <container_id>

$ docker container run hello-world
Realiza as seguintes operações:
* Download automático da imagem do docker hub se não foi encontrada localmente: docker image pull hello-world
* Cria o container: docker container create hello-world
* Inicia o container: docker container start <container_id>
* Usa o modo interativo para executar o container: docker container exec -i <container_id> <command>

* Cria um container baseado na imagem do alpine, executa um comando dentro do container, sai do container e exibe 
o resultado do comando no terminal:
$ docker container run alpine ls -l

* Cria um container baseado na imagem do alpine de tag 3.12, com terminal aberto dentro do container:
$ docker container run -it alpine:3.12

* Cria um container baseado na imagem do alpine de tag 3.12, com terminal aberto dentro do container (-it) e exclui o 
container ao sair do terminal (--rm):
$ docker container run -it --rm alpine:3.12

$ docker container run --name mycontainer -p 8080:80 -v /d/Projects/Docker/volumes/nginx/html:/usr/share/nginx/html -d nginx
--name: nome do container
-p: mapeamento de portas (host:container)
-v: mapeamento de volume ou pasta (host:container)
-d: executa o comando em segundo plano, evitando o travamento do terminal (detached)
nginx (lê-se engine-x): nome da imagem

$ docker container run --name mycontainer -it mcr.microsoft.com/dotnet/core/sdk
--name: nome do container
-it: modo interativo com terminal aberto dentro do container
mcr.microsoft.com/dotnet/core/sdk: nome da imagem

* Obtém informações do container, como uso de cpu, de memória, I/O, etc.:
$ docker container stats <container_id>

* Inspeciona o container:
$ docker container inspect <container_id>

$ docker image build -t debian/nginx:1.0 .
-t: Nome e opcionalmente uma tag no formato 'name:tag'.
.: Informa que o arquivo Dockerfile está no mesmo diretório em que o comando é executado.

* Cria um container baseado na imagem criada acima:
$ docker container run -d --name debian8 -p 8080:80 debian/nginx:1.0

* Exibe logs de criação do container:
$ docker container logs <container_id>

* Faz upload da imagem para o repositório do docker hub:
$ docker login
$ docker image tag debian/nginx:1.0 nelsonrzjunior/course:debian8
$ docker image push nelsonrzjunior/course:debian8

* Cria um volume (mapeamento de pastas entre host e container):
$ docker container run -it --name alpinevol -v /d/Projects/docker/volumes/alpine:/usr/share alpine

- A pasta 'Projects' é case-sensitive e deve ser definida exatamente como na VM (Shared Folders).
- Para testar o volume criado acima:
- Dentro do container, acessar o diretório mapeado com o comando: cd usr/share
- Criar um arquivo com o comando: echo 'Teste de volume do alpine...' > file.txt
- Verificar se o mesmo arquivo foi criado na pasta mapeada do host.

* Cria um volume:
$ docker volume create <volume_name>

* Lista os volumes:
$ docker volume ls

* Inspeciona um volume
$ docker image inspect <volume_name>

* Compartilhar o volume "Volume1" criado no container "container1" com o container "container2":
$ docker container run -it --name container1 -v /Volume1 alpine
$ docker container run -it --name container2 --volumes-from container1 alpine
- Para posteriormente acessar os containeres criados acima: docker container start -ia <container_name>

* Cria um container a partir da imagem do MySQL, com um mapeamento entre um volume criado localmente e outro dentro do container, 
junto com uma variável de ambiente que contém uma senha obrigatória para a conta de um super usuário:
$ docker container run -d --name mysql -v AppData:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=12345678 -e bind-address=0.0.0.0 mysql
-d: executa o container em segundo plano
-e: variáveis de ambiente. Para o MySQL aceitar requisições de todas as interfaces de rede, utilizar bind-address=0.0.0.0

- Para obter o volume do container, basta inspecionar a imagem e obter o valor da seção "Config:Volumes":
"Volumes": {
    "/var/lib/mysql": {}
}

* Abre um terminal dentro do container criado acima:
$ docker container exec -it mysql /bin/bash

* Faz login no MySQL:
/# mysql -u root -p

* Exibe as redes virtuais do Docker. A rede "bridge" é a rede padrão na qual os containeres são incluídos.
$ docker network ls

* Inspeciona o driver de rede especificado:
$ docker network inspect bridge

* Cria uma rede customizada. O nome do container passa a agir como um host name.
$ docker network create --driver bridge <my-network>
- driver: o driver de rede a ser utilizado. Se não for informado, o Docker utiliza o driver "bridge".

* Cria um container configurando uma rede personalizada:
$ docker container run -it --network <my-network> --name <container_name> alpine

* Associa um container a uma rede customizada:
$ docker network connect <my-network> <container_name>
